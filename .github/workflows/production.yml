name: cd

on:
  push:
    branches:
      - main

concurrency:
  group: cd-production
  cancel-in-progress: true

jobs:
  validate_and_correct_version:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    outputs:
      corrected_version: ${{ steps.correct.outputs.version }}
      version_was_corrected: ${{ steps.correct.outputs.corrected }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Validate and correct version for sequential ordering
        id: correct
        run: |
          CURRENT_VERSION=$(jq -r .version package.json)
          echo "Current version on main: ${CURRENT_VERSION}"
          
          # Get the previous commit's version (before this merge)
          PREVIOUS_VERSION=$(git show HEAD~1:package.json 2>/dev/null | jq -r .version || echo "0.0.0")
          echo "Previous version on main: ${PREVIOUS_VERSION}"
          
          RESULT=$(node - <<EOF
            const fs = require('fs');
            const current = '${CURRENT_VERSION}';
            const previous = '${PREVIOUS_VERSION}';
            
            const parse = (v) => v.split('.').map(Number);
            const cmp = (a, b) => {
              for (let i = 0; i < Math.max(a.length, b.length); i += 1) {
                const left = a[i] ?? 0;
                const right = b[i] ?? 0;
                if (left !== right) return left - right;
              }
              return 0;
            };
            
            const currentParts = parse(current);
            const previousParts = parse(previous);
            
            // Calculate what the next sequential version should be
            const nextParts = [...previousParts];
            nextParts[2] = (nextParts[2] ?? 0) + 1;
            const nextVersion = nextParts.join('.');
            
            // If current version is not sequential, correct it
            if (cmp(currentParts, nextParts) !== 0) {
              const pkg = JSON.parse(fs.readFileSync('package.json', 'utf8'));
              pkg.version = nextVersion;
              fs.writeFileSync('package.json', JSON.stringify(pkg, null, 2) + '\\n');
              
              // Create release notes if missing
              const notesFile = \`docs/release_notes/\${nextVersion}.md\`;
              if (!fs.existsSync(notesFile)) {
                fs.mkdirSync('docs/release_notes', { recursive: true });
                fs.writeFileSync(notesFile, \`# Release notes for \${nextVersion}\n\n- TODO: Describe changes included in this release.\n\`);
              }
              
              console.log(\`Version corrected from \${current} to \${nextVersion}\`);
              console.log(\`VERSION=\${nextVersion}\`);
              console.log(\`CORRECTED=true\`);
            } else {
              console.log(\`Version \${current} is already sequential\`);
              console.log(\`VERSION=\${current}\`);
              console.log(\`CORRECTED=false\`);
            }
          EOF
          )
          
          VERSION=$(echo "$RESULT" | grep "^VERSION=" | cut -d'=' -f2)
          CORRECTED=$(echo "$RESULT" | grep "^CORRECTED=" | cut -d'=' -f2)
          
          echo "version=${VERSION}" >> "$GITHUB_OUTPUT"
          echo "corrected=${CORRECTED}" >> "$GITHUB_OUTPUT"
          
          if [ "${CORRECTED}" == "true" ]; then
            echo "Version was corrected from ${CURRENT_VERSION} to ${VERSION}, committing fix..."
            git config user.name "github-actions[bot]"
            git config user.email "github-actions[bot]@users.noreply.github.com"
            git add package.json docs/release_notes/
            git commit -m "chore: correct version to ${VERSION} to maintain sequential ordering [auto-version-fix]"
            git push origin main
            echo "✅ Version corrected and pushed"
          else
            echo "✅ Version ${VERSION} is already sequential, no correction needed"
          fi

  release_notes_check:
    needs: validate_and_correct_version
    runs-on: ubuntu-latest
    outputs:
      release_notes: ${{ steps.check.outputs.release_notes }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Check release notes
        id: check
        uses: ./.github/actions/release_notes_check
        with:
          version_file: 'package.json'
          notes_dir: 'docs/release_notes'
          notes_ext: '.md'

  deploy_android:
    runs-on: ubuntu-latest
    needs: [validate_and_correct_version, release_notes_check]
    steps:
      - name: Checkout (app)
        uses: actions/checkout@v3

      - name: Deploy Android app to Play Store
        id: deploy_android_production
        uses: ./.github/actions/deploy_android_production
        with:
          GPLAY_SERVICE_ACCOUNT_KEY_JSON: ${{ secrets.GPLAY_SERVICE_ACCOUNT_KEY_JSON }}
          ANDROID_KEYSTORE_FILE: ${{ secrets.ANDROID_KEYSTORE_FILE }}
          ANDROID_KEYSTORE_PASSWORD: ${{ secrets.ANDROID_KEYSTORE_PASSWORD }}
          ANDROID_KEY_ALIAS: ${{ secrets.ANDROID_KEY_ALIAS }}
          ANDROID_KEY_PASSWORD: ${{ secrets.ANDROID_KEY_PASSWORD }}
          RELEASE_NOTES: ${{ needs.release_notes_check.outputs.release_notes }}

  # deploy-ios:
  #   runs-on: macos-14
  #   needs: [release_notes_check]
  #   timeout-minutes: 30
  #   steps:
  #     - name: Checkout (app)
  #       uses: actions/checkout@v3

  #     - name: Deploy iOS app to App Store
  #       uses: ./.github/actions/deploy_ios_production
  #       with:
  #         MATCH_PASSWORD: ${{ secrets.IOS_MATCH_PASSWORD }}
  #         IOS_MATCH_REPOSITORY_URL: ${{ secrets.IOS_MATCH_REPOSITORY_URL }}
  #         IOS_APPLE_ID: ${{ secrets.IOS_APPLE_ID }}
  #         IOS_KEYCHAIN_PASSWORD: ${{ secrets.IOS_KEYCHAIN_PASSWORD }}
  #         IOS_APP_STORE_CONNECT_API_KEY_ID: ${{ secrets.IOS_APP_STORE_CONNECT_API_KEY_ID }}
  #         IOS_APP_STORE_CONNECT_API_KEY_ISSUER_ID: ${{ secrets.IOS_APP_STORE_CONNECT_API_KEY_ISSUER_ID }}
  #         IOS_APP_STORE_CONNECT_API_KEY_B64: ${{ secrets.IOS_APP_STORE_CONNECT_API_KEY_B64 }}
  #         IOS_APP_IDENTIFIER: ${{ secrets.IOS_APP_IDENTIFIER }}
  #         IOS_APP_STORE_TEAM_ID: ${{ secrets.IOS_APP_STORE_TEAM_ID }}
  #         IOS_DEV_EMAIL: ${{ secrets.IOS_DEV_EMAIL }}
  #         IOS_MATCH_DEPLOY_KEY: ${{ secrets.IOS_MATCH_DEPLOY_KEY }}
  #         RELEASE_NOTES: ${{ needs.release_notes_check.outputs.release_notes }}